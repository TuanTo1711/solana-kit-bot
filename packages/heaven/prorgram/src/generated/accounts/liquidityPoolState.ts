/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getF64Decoder,
  getF64Encoder,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  getU8Decoder,
  getU8Encoder,
  transformEncoder,
  type Account,
  type Address,
  type EncodedAccount,
  type FetchAccountConfig,
  type FetchAccountsConfig,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type MaybeAccount,
  type MaybeEncodedAccount,
  type ReadonlyUint8Array,
} from '@solana/kit'
import {
  getLiquidityPoolAllowlistDecoder,
  getLiquidityPoolAllowlistEncoder,
  getLiquidityPoolFeatureFlagsDecoder,
  getLiquidityPoolFeatureFlagsEncoder,
  getLiquidityPoolInfoDecoder,
  getLiquidityPoolInfoEncoder,
  getLiquidityPoolLpTokenInfoDecoder,
  getLiquidityPoolLpTokenInfoEncoder,
  getLiquidityPoolMarketCapBasedFeesDecoder,
  getLiquidityPoolMarketCapBasedFeesEncoder,
  getLiquidityPoolReserveDecoder,
  getLiquidityPoolReserveEncoder,
  getLiquidityPoolSlotOffsetBasedFeesDecoder,
  getLiquidityPoolSlotOffsetBasedFeesEncoder,
  getLiquidityPoolTokenInfoDecoder,
  getLiquidityPoolTokenInfoEncoder,
  type LiquidityPoolAllowlist,
  type LiquidityPoolAllowlistArgs,
  type LiquidityPoolFeatureFlags,
  type LiquidityPoolFeatureFlagsArgs,
  type LiquidityPoolInfo,
  type LiquidityPoolInfoArgs,
  type LiquidityPoolLpTokenInfo,
  type LiquidityPoolLpTokenInfoArgs,
  type LiquidityPoolMarketCapBasedFees,
  type LiquidityPoolMarketCapBasedFeesArgs,
  type LiquidityPoolReserve,
  type LiquidityPoolReserveArgs,
  type LiquidityPoolSlotOffsetBasedFees,
  type LiquidityPoolSlotOffsetBasedFeesArgs,
  type LiquidityPoolTokenInfo,
  type LiquidityPoolTokenInfoArgs,
} from '../types'

export const LIQUIDITY_POOL_STATE_DISCRIMINATOR = new Uint8Array([
  190, 158, 220, 130, 15, 162, 132, 252,
])

export function getLiquidityPoolStateDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(LIQUIDITY_POOL_STATE_DISCRIMINATOR)
}

export type LiquidityPoolState = {
  discriminator: ReadonlyUint8Array
  info: LiquidityPoolInfo
  marketCapBasedFees: LiquidityPoolMarketCapBasedFees
  reserve: LiquidityPoolReserve
  lpToken: LiquidityPoolLpTokenInfo
  protocolTradingFees: bigint
  creatorTradingFees: bigint
  creatorTradingFeesClaimedByCreator: bigint
  creatorTradingFeesClaimedByOthers: bigint
  liquidityProviderTradingFees: bigint
  creatorTradingFeeProtocolFees: bigint
  reflectionTradingFees: bigint
  createdAtSlot: bigint
  tradingVolumeUsd: number
  creatorTradingFeeTradingVolumeThreshold: number
  creatorTradingFeeTradingVolumeThresholdReachedUnixTimestamp: bigint
  tokenAVault: Address
  tokenBVault: Address
  protocolConfig: Address
  key: Address
  tokenA: LiquidityPoolTokenInfo
  tokenB: LiquidityPoolTokenInfo
  allowlist: LiquidityPoolAllowlist
  featureFlags: LiquidityPoolFeatureFlags
  taxableSide: number
  taxableSideType: number
  creatorTradingFeeDistribution: number
  creatorTradingFeeClaimStatus: number
  feeConfigurationMode: number
  isMigrated: number
  pad: ReadonlyUint8Array
  slotOffsetBasedFees: LiquidityPoolSlotOffsetBasedFees
  creatorTradingFeeReceiver: Address
}

export type LiquidityPoolStateArgs = {
  info: LiquidityPoolInfoArgs
  marketCapBasedFees: LiquidityPoolMarketCapBasedFeesArgs
  reserve: LiquidityPoolReserveArgs
  lpToken: LiquidityPoolLpTokenInfoArgs
  protocolTradingFees: number | bigint
  creatorTradingFees: number | bigint
  creatorTradingFeesClaimedByCreator: number | bigint
  creatorTradingFeesClaimedByOthers: number | bigint
  liquidityProviderTradingFees: number | bigint
  creatorTradingFeeProtocolFees: number | bigint
  reflectionTradingFees: number | bigint
  createdAtSlot: number | bigint
  tradingVolumeUsd: number
  creatorTradingFeeTradingVolumeThreshold: number
  creatorTradingFeeTradingVolumeThresholdReachedUnixTimestamp: number | bigint
  tokenAVault: Address
  tokenBVault: Address
  protocolConfig: Address
  key: Address
  tokenA: LiquidityPoolTokenInfoArgs
  tokenB: LiquidityPoolTokenInfoArgs
  allowlist: LiquidityPoolAllowlistArgs
  featureFlags: LiquidityPoolFeatureFlagsArgs
  taxableSide: number
  taxableSideType: number
  creatorTradingFeeDistribution: number
  creatorTradingFeeClaimStatus: number
  feeConfigurationMode: number
  isMigrated: number
  pad: ReadonlyUint8Array
  slotOffsetBasedFees: LiquidityPoolSlotOffsetBasedFeesArgs
  creatorTradingFeeReceiver: Address
}

export function getLiquidityPoolStateEncoder(): FixedSizeEncoder<LiquidityPoolStateArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['info', getLiquidityPoolInfoEncoder()],
      ['marketCapBasedFees', getLiquidityPoolMarketCapBasedFeesEncoder()],
      ['reserve', getLiquidityPoolReserveEncoder()],
      ['lpToken', getLiquidityPoolLpTokenInfoEncoder()],
      ['protocolTradingFees', getU64Encoder()],
      ['creatorTradingFees', getU64Encoder()],
      ['creatorTradingFeesClaimedByCreator', getU64Encoder()],
      ['creatorTradingFeesClaimedByOthers', getU64Encoder()],
      ['liquidityProviderTradingFees', getU64Encoder()],
      ['creatorTradingFeeProtocolFees', getU64Encoder()],
      ['reflectionTradingFees', getU64Encoder()],
      ['createdAtSlot', getU64Encoder()],
      ['tradingVolumeUsd', getF64Encoder()],
      ['creatorTradingFeeTradingVolumeThreshold', getF64Encoder()],
      ['creatorTradingFeeTradingVolumeThresholdReachedUnixTimestamp', getU64Encoder()],
      ['tokenAVault', getAddressEncoder()],
      ['tokenBVault', getAddressEncoder()],
      ['protocolConfig', getAddressEncoder()],
      ['key', getAddressEncoder()],
      ['tokenA', getLiquidityPoolTokenInfoEncoder()],
      ['tokenB', getLiquidityPoolTokenInfoEncoder()],
      ['allowlist', getLiquidityPoolAllowlistEncoder()],
      ['featureFlags', getLiquidityPoolFeatureFlagsEncoder()],
      ['taxableSide', getU8Encoder()],
      ['taxableSideType', getU8Encoder()],
      ['creatorTradingFeeDistribution', getU8Encoder()],
      ['creatorTradingFeeClaimStatus', getU8Encoder()],
      ['feeConfigurationMode', getU8Encoder()],
      ['isMigrated', getU8Encoder()],
      ['pad', fixEncoderSize(getBytesEncoder(), 13)],
      ['slotOffsetBasedFees', getLiquidityPoolSlotOffsetBasedFeesEncoder()],
      ['creatorTradingFeeReceiver', getAddressEncoder()],
    ]),
    value => ({ ...value, discriminator: LIQUIDITY_POOL_STATE_DISCRIMINATOR })
  )
}

export function getLiquidityPoolStateDecoder(): FixedSizeDecoder<LiquidityPoolState> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['info', getLiquidityPoolInfoDecoder()],
    ['marketCapBasedFees', getLiquidityPoolMarketCapBasedFeesDecoder()],
    ['reserve', getLiquidityPoolReserveDecoder()],
    ['lpToken', getLiquidityPoolLpTokenInfoDecoder()],
    ['protocolTradingFees', getU64Decoder()],
    ['creatorTradingFees', getU64Decoder()],
    ['creatorTradingFeesClaimedByCreator', getU64Decoder()],
    ['creatorTradingFeesClaimedByOthers', getU64Decoder()],
    ['liquidityProviderTradingFees', getU64Decoder()],
    ['creatorTradingFeeProtocolFees', getU64Decoder()],
    ['reflectionTradingFees', getU64Decoder()],
    ['createdAtSlot', getU64Decoder()],
    ['tradingVolumeUsd', getF64Decoder()],
    ['creatorTradingFeeTradingVolumeThreshold', getF64Decoder()],
    ['creatorTradingFeeTradingVolumeThresholdReachedUnixTimestamp', getU64Decoder()],
    ['tokenAVault', getAddressDecoder()],
    ['tokenBVault', getAddressDecoder()],
    ['protocolConfig', getAddressDecoder()],
    ['key', getAddressDecoder()],
    ['tokenA', getLiquidityPoolTokenInfoDecoder()],
    ['tokenB', getLiquidityPoolTokenInfoDecoder()],
    ['allowlist', getLiquidityPoolAllowlistDecoder()],
    ['featureFlags', getLiquidityPoolFeatureFlagsDecoder()],
    ['taxableSide', getU8Decoder()],
    ['taxableSideType', getU8Decoder()],
    ['creatorTradingFeeDistribution', getU8Decoder()],
    ['creatorTradingFeeClaimStatus', getU8Decoder()],
    ['feeConfigurationMode', getU8Decoder()],
    ['isMigrated', getU8Decoder()],
    ['pad', fixDecoderSize(getBytesDecoder(), 13)],
    ['slotOffsetBasedFees', getLiquidityPoolSlotOffsetBasedFeesDecoder()],
    ['creatorTradingFeeReceiver', getAddressDecoder()],
  ])
}

export function getLiquidityPoolStateCodec(): FixedSizeCodec<
  LiquidityPoolStateArgs,
  LiquidityPoolState
> {
  return combineCodec(getLiquidityPoolStateEncoder(), getLiquidityPoolStateDecoder())
}

export function decodeLiquidityPoolState<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>
): Account<LiquidityPoolState, TAddress>
export function decodeLiquidityPoolState<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>
): MaybeAccount<LiquidityPoolState, TAddress>
export function decodeLiquidityPoolState<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>
): Account<LiquidityPoolState, TAddress> | MaybeAccount<LiquidityPoolState, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getLiquidityPoolStateDecoder()
  )
}

export async function fetchLiquidityPoolState<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<Account<LiquidityPoolState, TAddress>> {
  const maybeAccount = await fetchMaybeLiquidityPoolState(rpc, address, config)
  assertAccountExists(maybeAccount)
  return maybeAccount
}

export async function fetchMaybeLiquidityPoolState<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<MaybeAccount<LiquidityPoolState, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config)
  return decodeLiquidityPoolState(maybeAccount)
}

export async function fetchAllLiquidityPoolState(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<Account<LiquidityPoolState>[]> {
  const maybeAccounts = await fetchAllMaybeLiquidityPoolState(rpc, addresses, config)
  assertAccountsExist(maybeAccounts)
  return maybeAccounts
}

export async function fetchAllMaybeLiquidityPoolState(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<MaybeAccount<LiquidityPoolState>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config)
  return maybeAccounts.map(maybeAccount => decodeLiquidityPoolState(maybeAccount))
}

export function getLiquidityPoolStateSize(): number {
  return 2304
}
