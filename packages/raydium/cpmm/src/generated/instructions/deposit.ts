/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getProgramDerivedAddress,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type ReadonlyAccount,
  type ReadonlySignerAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
} from '@solana/kit'
import { RAYDIUM_CP_SWAP_PROGRAM_ADDRESS } from '../programs'
import { getAccountMetaFactory, type ResolvedAccount } from '../shared'

export const DEPOSIT_DISCRIMINATOR = new Uint8Array([242, 35, 198, 137, 82, 225, 242, 182])

export function getDepositDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(DEPOSIT_DISCRIMINATOR)
}

export type DepositInstruction<
  TProgram extends string = typeof RAYDIUM_CP_SWAP_PROGRAM_ADDRESS,
  TAccountOwner extends string | AccountMeta<string> = string,
  TAccountAuthority extends string | AccountMeta<string> = string,
  TAccountPoolState extends string | AccountMeta<string> = string,
  TAccountOwnerLpToken extends string | AccountMeta<string> = string,
  TAccountToken0Account extends string | AccountMeta<string> = string,
  TAccountToken1Account extends string | AccountMeta<string> = string,
  TAccountToken0Vault extends string | AccountMeta<string> = string,
  TAccountToken1Vault extends string | AccountMeta<string> = string,
  TAccountTokenProgram extends
    | string
    | AccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
  TAccountTokenProgram2022 extends
    | string
    | AccountMeta<string> = 'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb',
  TAccountVault0Mint extends string | AccountMeta<string> = string,
  TAccountVault1Mint extends string | AccountMeta<string> = string,
  TAccountLpMint extends string | AccountMeta<string> = string,
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountOwner extends string
        ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>
        : TAccountOwner,
      TAccountAuthority extends string ? ReadonlyAccount<TAccountAuthority> : TAccountAuthority,
      TAccountPoolState extends string ? WritableAccount<TAccountPoolState> : TAccountPoolState,
      TAccountOwnerLpToken extends string
        ? WritableAccount<TAccountOwnerLpToken>
        : TAccountOwnerLpToken,
      TAccountToken0Account extends string
        ? WritableAccount<TAccountToken0Account>
        : TAccountToken0Account,
      TAccountToken1Account extends string
        ? WritableAccount<TAccountToken1Account>
        : TAccountToken1Account,
      TAccountToken0Vault extends string
        ? WritableAccount<TAccountToken0Vault>
        : TAccountToken0Vault,
      TAccountToken1Vault extends string
        ? WritableAccount<TAccountToken1Vault>
        : TAccountToken1Vault,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      TAccountTokenProgram2022 extends string
        ? ReadonlyAccount<TAccountTokenProgram2022>
        : TAccountTokenProgram2022,
      TAccountVault0Mint extends string ? ReadonlyAccount<TAccountVault0Mint> : TAccountVault0Mint,
      TAccountVault1Mint extends string ? ReadonlyAccount<TAccountVault1Mint> : TAccountVault1Mint,
      TAccountLpMint extends string ? WritableAccount<TAccountLpMint> : TAccountLpMint,
      ...TRemainingAccounts,
    ]
  >

export type DepositInstructionData = {
  discriminator: ReadonlyUint8Array
  lpTokenAmount: bigint
  maximumToken0Amount: bigint
  maximumToken1Amount: bigint
}

export type DepositInstructionDataArgs = {
  lpTokenAmount: number | bigint
  maximumToken0Amount: number | bigint
  maximumToken1Amount: number | bigint
}

export function getDepositInstructionDataEncoder(): FixedSizeEncoder<DepositInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['lpTokenAmount', getU64Encoder()],
      ['maximumToken0Amount', getU64Encoder()],
      ['maximumToken1Amount', getU64Encoder()],
    ]),
    value => ({ ...value, discriminator: DEPOSIT_DISCRIMINATOR })
  )
}

export function getDepositInstructionDataDecoder(): FixedSizeDecoder<DepositInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['lpTokenAmount', getU64Decoder()],
    ['maximumToken0Amount', getU64Decoder()],
    ['maximumToken1Amount', getU64Decoder()],
  ])
}

export function getDepositInstructionDataCodec(): FixedSizeCodec<
  DepositInstructionDataArgs,
  DepositInstructionData
> {
  return combineCodec(getDepositInstructionDataEncoder(), getDepositInstructionDataDecoder())
}

export type DepositAsyncInput<
  TAccountOwner extends string = string,
  TAccountAuthority extends string = string,
  TAccountPoolState extends string = string,
  TAccountOwnerLpToken extends string = string,
  TAccountToken0Account extends string = string,
  TAccountToken1Account extends string = string,
  TAccountToken0Vault extends string = string,
  TAccountToken1Vault extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountTokenProgram2022 extends string = string,
  TAccountVault0Mint extends string = string,
  TAccountVault1Mint extends string = string,
  TAccountLpMint extends string = string,
> = {
  /** Pays to mint the position */
  owner: TransactionSigner<TAccountOwner>
  authority?: Address<TAccountAuthority>
  poolState: Address<TAccountPoolState>
  /** Owner lp token account */
  ownerLpToken: Address<TAccountOwnerLpToken>
  /** The payer's token account for token_0 */
  token0Account: Address<TAccountToken0Account>
  /** The payer's token account for token_1 */
  token1Account: Address<TAccountToken1Account>
  /** The address that holds pool tokens for token_0 */
  token0Vault: Address<TAccountToken0Vault>
  /** The address that holds pool tokens for token_1 */
  token1Vault: Address<TAccountToken1Vault>
  /** token Program */
  tokenProgram?: Address<TAccountTokenProgram>
  /** Token program 2022 */
  tokenProgram2022?: Address<TAccountTokenProgram2022>
  /** The mint of token_0 vault */
  vault0Mint: Address<TAccountVault0Mint>
  /** The mint of token_1 vault */
  vault1Mint: Address<TAccountVault1Mint>
  /** Lp token mint */
  lpMint: Address<TAccountLpMint>
  lpTokenAmount: DepositInstructionDataArgs['lpTokenAmount']
  maximumToken0Amount: DepositInstructionDataArgs['maximumToken0Amount']
  maximumToken1Amount: DepositInstructionDataArgs['maximumToken1Amount']
}

export async function getDepositInstructionAsync<
  TAccountOwner extends string,
  TAccountAuthority extends string,
  TAccountPoolState extends string,
  TAccountOwnerLpToken extends string,
  TAccountToken0Account extends string,
  TAccountToken1Account extends string,
  TAccountToken0Vault extends string,
  TAccountToken1Vault extends string,
  TAccountTokenProgram extends string,
  TAccountTokenProgram2022 extends string,
  TAccountVault0Mint extends string,
  TAccountVault1Mint extends string,
  TAccountLpMint extends string,
  TProgramAddress extends Address = typeof RAYDIUM_CP_SWAP_PROGRAM_ADDRESS,
>(
  input: DepositAsyncInput<
    TAccountOwner,
    TAccountAuthority,
    TAccountPoolState,
    TAccountOwnerLpToken,
    TAccountToken0Account,
    TAccountToken1Account,
    TAccountToken0Vault,
    TAccountToken1Vault,
    TAccountTokenProgram,
    TAccountTokenProgram2022,
    TAccountVault0Mint,
    TAccountVault1Mint,
    TAccountLpMint
  >,
  config?: { programAddress?: TProgramAddress }
): Promise<
  DepositInstruction<
    TProgramAddress,
    TAccountOwner,
    TAccountAuthority,
    TAccountPoolState,
    TAccountOwnerLpToken,
    TAccountToken0Account,
    TAccountToken1Account,
    TAccountToken0Vault,
    TAccountToken1Vault,
    TAccountTokenProgram,
    TAccountTokenProgram2022,
    TAccountVault0Mint,
    TAccountVault1Mint,
    TAccountLpMint
  >
> {
  // Program address.
  const programAddress = config?.programAddress ?? RAYDIUM_CP_SWAP_PROGRAM_ADDRESS

  // Original accounts.
  const originalAccounts = {
    owner: { value: input.owner ?? null, isWritable: false },
    authority: { value: input.authority ?? null, isWritable: false },
    poolState: { value: input.poolState ?? null, isWritable: true },
    ownerLpToken: { value: input.ownerLpToken ?? null, isWritable: true },
    token0Account: { value: input.token0Account ?? null, isWritable: true },
    token1Account: { value: input.token1Account ?? null, isWritable: true },
    token0Vault: { value: input.token0Vault ?? null, isWritable: true },
    token1Vault: { value: input.token1Vault ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    tokenProgram2022: {
      value: input.tokenProgram2022 ?? null,
      isWritable: false,
    },
    vault0Mint: { value: input.vault0Mint ?? null, isWritable: false },
    vault1Mint: { value: input.vault1Mint ?? null, isWritable: false },
    lpMint: { value: input.lpMint ?? null, isWritable: true },
  }
  const accounts = originalAccounts as Record<keyof typeof originalAccounts, ResolvedAccount>

  // Original args.
  const args = { ...input }

  // Resolve default values.
  if (!accounts.authority.value) {
    accounts.authority.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            118, 97, 117, 108, 116, 95, 97, 110, 100, 95, 108, 112, 95, 109, 105, 110, 116, 95, 97,
            117, 116, 104, 95, 115, 101, 101, 100,
          ])
        ),
      ],
    })
  }
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>
  }
  if (!accounts.tokenProgram2022.value) {
    accounts.tokenProgram2022.value =
      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId')
  const instruction = {
    accounts: [
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.poolState),
      getAccountMeta(accounts.ownerLpToken),
      getAccountMeta(accounts.token0Account),
      getAccountMeta(accounts.token1Account),
      getAccountMeta(accounts.token0Vault),
      getAccountMeta(accounts.token1Vault),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.tokenProgram2022),
      getAccountMeta(accounts.vault0Mint),
      getAccountMeta(accounts.vault1Mint),
      getAccountMeta(accounts.lpMint),
    ],
    programAddress,
    data: getDepositInstructionDataEncoder().encode(args as DepositInstructionDataArgs),
  } as DepositInstruction<
    TProgramAddress,
    TAccountOwner,
    TAccountAuthority,
    TAccountPoolState,
    TAccountOwnerLpToken,
    TAccountToken0Account,
    TAccountToken1Account,
    TAccountToken0Vault,
    TAccountToken1Vault,
    TAccountTokenProgram,
    TAccountTokenProgram2022,
    TAccountVault0Mint,
    TAccountVault1Mint,
    TAccountLpMint
  >

  return instruction
}

export type DepositInput<
  TAccountOwner extends string = string,
  TAccountAuthority extends string = string,
  TAccountPoolState extends string = string,
  TAccountOwnerLpToken extends string = string,
  TAccountToken0Account extends string = string,
  TAccountToken1Account extends string = string,
  TAccountToken0Vault extends string = string,
  TAccountToken1Vault extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountTokenProgram2022 extends string = string,
  TAccountVault0Mint extends string = string,
  TAccountVault1Mint extends string = string,
  TAccountLpMint extends string = string,
> = {
  /** Pays to mint the position */
  owner: TransactionSigner<TAccountOwner>
  authority: Address<TAccountAuthority>
  poolState: Address<TAccountPoolState>
  /** Owner lp token account */
  ownerLpToken: Address<TAccountOwnerLpToken>
  /** The payer's token account for token_0 */
  token0Account: Address<TAccountToken0Account>
  /** The payer's token account for token_1 */
  token1Account: Address<TAccountToken1Account>
  /** The address that holds pool tokens for token_0 */
  token0Vault: Address<TAccountToken0Vault>
  /** The address that holds pool tokens for token_1 */
  token1Vault: Address<TAccountToken1Vault>
  /** token Program */
  tokenProgram?: Address<TAccountTokenProgram>
  /** Token program 2022 */
  tokenProgram2022?: Address<TAccountTokenProgram2022>
  /** The mint of token_0 vault */
  vault0Mint: Address<TAccountVault0Mint>
  /** The mint of token_1 vault */
  vault1Mint: Address<TAccountVault1Mint>
  /** Lp token mint */
  lpMint: Address<TAccountLpMint>
  lpTokenAmount: DepositInstructionDataArgs['lpTokenAmount']
  maximumToken0Amount: DepositInstructionDataArgs['maximumToken0Amount']
  maximumToken1Amount: DepositInstructionDataArgs['maximumToken1Amount']
}

export function getDepositInstruction<
  TAccountOwner extends string,
  TAccountAuthority extends string,
  TAccountPoolState extends string,
  TAccountOwnerLpToken extends string,
  TAccountToken0Account extends string,
  TAccountToken1Account extends string,
  TAccountToken0Vault extends string,
  TAccountToken1Vault extends string,
  TAccountTokenProgram extends string,
  TAccountTokenProgram2022 extends string,
  TAccountVault0Mint extends string,
  TAccountVault1Mint extends string,
  TAccountLpMint extends string,
  TProgramAddress extends Address = typeof RAYDIUM_CP_SWAP_PROGRAM_ADDRESS,
>(
  input: DepositInput<
    TAccountOwner,
    TAccountAuthority,
    TAccountPoolState,
    TAccountOwnerLpToken,
    TAccountToken0Account,
    TAccountToken1Account,
    TAccountToken0Vault,
    TAccountToken1Vault,
    TAccountTokenProgram,
    TAccountTokenProgram2022,
    TAccountVault0Mint,
    TAccountVault1Mint,
    TAccountLpMint
  >,
  config?: { programAddress?: TProgramAddress }
): DepositInstruction<
  TProgramAddress,
  TAccountOwner,
  TAccountAuthority,
  TAccountPoolState,
  TAccountOwnerLpToken,
  TAccountToken0Account,
  TAccountToken1Account,
  TAccountToken0Vault,
  TAccountToken1Vault,
  TAccountTokenProgram,
  TAccountTokenProgram2022,
  TAccountVault0Mint,
  TAccountVault1Mint,
  TAccountLpMint
> {
  // Program address.
  const programAddress = config?.programAddress ?? RAYDIUM_CP_SWAP_PROGRAM_ADDRESS

  // Original accounts.
  const originalAccounts = {
    owner: { value: input.owner ?? null, isWritable: false },
    authority: { value: input.authority ?? null, isWritable: false },
    poolState: { value: input.poolState ?? null, isWritable: true },
    ownerLpToken: { value: input.ownerLpToken ?? null, isWritable: true },
    token0Account: { value: input.token0Account ?? null, isWritable: true },
    token1Account: { value: input.token1Account ?? null, isWritable: true },
    token0Vault: { value: input.token0Vault ?? null, isWritable: true },
    token1Vault: { value: input.token1Vault ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    tokenProgram2022: {
      value: input.tokenProgram2022 ?? null,
      isWritable: false,
    },
    vault0Mint: { value: input.vault0Mint ?? null, isWritable: false },
    vault1Mint: { value: input.vault1Mint ?? null, isWritable: false },
    lpMint: { value: input.lpMint ?? null, isWritable: true },
  }
  const accounts = originalAccounts as Record<keyof typeof originalAccounts, ResolvedAccount>

  // Original args.
  const args = { ...input }

  // Resolve default values.
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>
  }
  if (!accounts.tokenProgram2022.value) {
    accounts.tokenProgram2022.value =
      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId')
  const instruction = {
    accounts: [
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.poolState),
      getAccountMeta(accounts.ownerLpToken),
      getAccountMeta(accounts.token0Account),
      getAccountMeta(accounts.token1Account),
      getAccountMeta(accounts.token0Vault),
      getAccountMeta(accounts.token1Vault),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.tokenProgram2022),
      getAccountMeta(accounts.vault0Mint),
      getAccountMeta(accounts.vault1Mint),
      getAccountMeta(accounts.lpMint),
    ],
    programAddress,
    data: getDepositInstructionDataEncoder().encode(args as DepositInstructionDataArgs),
  } as DepositInstruction<
    TProgramAddress,
    TAccountOwner,
    TAccountAuthority,
    TAccountPoolState,
    TAccountOwnerLpToken,
    TAccountToken0Account,
    TAccountToken1Account,
    TAccountToken0Vault,
    TAccountToken1Vault,
    TAccountTokenProgram,
    TAccountTokenProgram2022,
    TAccountVault0Mint,
    TAccountVault1Mint,
    TAccountLpMint
  >

  return instruction
}

export type ParsedDepositInstruction<
  TProgram extends string = typeof RAYDIUM_CP_SWAP_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>
  accounts: {
    /** Pays to mint the position */
    owner: TAccountMetas[0]
    authority: TAccountMetas[1]
    poolState: TAccountMetas[2]
    /** Owner lp token account */
    ownerLpToken: TAccountMetas[3]
    /** The payer's token account for token_0 */
    token0Account: TAccountMetas[4]
    /** The payer's token account for token_1 */
    token1Account: TAccountMetas[5]
    /** The address that holds pool tokens for token_0 */
    token0Vault: TAccountMetas[6]
    /** The address that holds pool tokens for token_1 */
    token1Vault: TAccountMetas[7]
    /** token Program */
    tokenProgram: TAccountMetas[8]
    /** Token program 2022 */
    tokenProgram2022: TAccountMetas[9]
    /** The mint of token_0 vault */
    vault0Mint: TAccountMetas[10]
    /** The mint of token_1 vault */
    vault1Mint: TAccountMetas[11]
    /** Lp token mint */
    lpMint: TAccountMetas[12]
  }
  data: DepositInstructionData
}

export function parseDepositInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedDepositInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 13) {
    // TODO: Coded error.
    throw new Error('Not enough accounts')
  }
  let accountIndex = 0
  const getNextAccount = () => {
    const accountMeta = instruction.accounts![accountIndex]!
    accountIndex += 1
    return accountMeta
  }
  return {
    programAddress: instruction.programAddress,
    accounts: {
      owner: getNextAccount(),
      authority: getNextAccount(),
      poolState: getNextAccount(),
      ownerLpToken: getNextAccount(),
      token0Account: getNextAccount(),
      token1Account: getNextAccount(),
      token0Vault: getNextAccount(),
      token1Vault: getNextAccount(),
      tokenProgram: getNextAccount(),
      tokenProgram2022: getNextAccount(),
      vault0Mint: getNextAccount(),
      vault1Mint: getNextAccount(),
      lpMint: getNextAccount(),
    },
    data: getDepositInstructionDataDecoder().decode(instruction.data),
  }
}
